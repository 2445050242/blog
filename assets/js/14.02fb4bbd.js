(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{517:function(_,v,i){"use strict";i.r(v);var l=i(4),e=Object(l.a)({},(function(){var _=this,v=_.$createElement,i=_._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[i("h2",{attrs:{id:"注意点"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[_._v("#")]),_._v(" 注意点")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("深拷贝"),i("code",[_._v("Object.assign")]),_._v("和浅拷贝"),i("code",[_._v("JSON.parse(JSON.stringify(obj))")])])]),_._v(" "),i("li",[i("p",[_._v("闭包的原理就是作用域链，比函数F内部有一个函数G，函数 G可以访问到函数F中的变量，那么函数G就是闭包。")])]),_._v(" "),i("li",[i("p",[i("code",[_._v("apply、call、bind")]),_._v("，call 传入参数列表，apply 传入数组，bind 是返回对应 函数，便于稍后调用；apply 、call 则是立即调用 。")])]),_._v(" "),i("li",[i("p",[_._v("宏任务和微任务，宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick等等）。")])]),_._v(" "),i("li",[i("p",[i("code",[_._v("Event Loop")]),_._v("，主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个循环往复的过程被称为“Event Loop 事件循环”")])]),_._v(" "),i("li",[i("p",[_._v("浏览器渲染页面的一般过程：")]),_._v(" "),i("ul",[i("li",[_._v("浏览器解析html源码，然后创建一个 DOM树。")]),_._v(" "),i("li",[_._v("浏览器解析CSS代码，计算出最终的样式数据。")]),_._v(" "),i("li",[_._v("DOM Tree + CSSOM --\x3e 渲染树（rendering tree）。")]),_._v(" "),i("li",[_._v("一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。")])])]),_._v(" "),i("li",[i("p",[_._v("vue路由：")]),_._v(" "),i("ul",[i("li",[_._v("hash模式："),i("br"),_._v("\n可以监听hashchange来实现更新页面部分内容的操作")]),_._v(" "),i("li",[_._v("history模式："),i("br"),_._v("\n但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。")])])]),_._v(" "),i("li",[i("p",[_._v("js的垃圾回收机制：")]),_._v(" "),i("ul",[i("li",[_._v("可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。")]),_._v(" "),i("li",[_._v("如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。")]),_._v(" "),i("li",[_._v("一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。")]),_._v(" "),i("li",[_._v("如何检垃圾：标记-清除 算法，引用计数")])])]),_._v(" "),i("li",[i("p",[_._v("引起内存泄漏的操作：")]),_._v(" "),i("ul",[i("li",[_._v("以外的全局变量，可以再文件头部添加'use strict'，避免此类错误发生")]),_._v(" "),i("li",[_._v("被遗忘的计时器或回调函数")]),_._v(" "),i("li",[_._v("闭包")]),_._v(" "),i("li",[_._v("没有清理的DOM元素引用")])])]),_._v(" "),i("li",[i("p",[_._v("rustful API规范：")]),_._v(" "),i("ul",[i("li",[_._v("接口一般使用名词复数")]),_._v(" "),i("li",[_._v("状态码必须明确")]),_._v(" "),i("li",[_._v("不返回纯文本，返回组成为"),i("code",[_._v("code + data + message")])]),_._v(" "),i("li",[_._v("返回数据格式一般为json，不要使用XML")])])]),_._v(" "),i("li",[i("p",[_._v("防抖和节流实现")])]),_._v(" "),i("li",[i("p",[_._v("React Hooks、mobx、redux")]),_._v(" "),i("ul",[i("li",[_._v("只能在最外层使用hooks，不然可能会导致执行循序错乱")]),_._v(" "),i("li",[_._v("只能在React的函数组件中或者自定义Hooks中调用hooks")]),_._v(" "),i("li",[_._v("useEffect可以返回一个清理函数，也可以传递第二个参数来决定是否更新，如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect")]),_._v(" "),i("li",[_._v("如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数")]),_._v(" "),i("li",[_._v("自定义Hooks必须以"),i("code",[_._v("use")]),_._v("开头，并且不会共享state，完全独立")]),_._v(" "),i("li",[_._v("redux（dva/rematch）两者的区别主要在于对异步的处理，dva选择了用generator，而rematch选择了用async/await")]),_._v(" "),i("li",[_._v("HOC和renderProps")]),_._v(" "),i("li",[_._v("hooks的可行逻辑排序（各种hook，同步的业务逻辑，render逻辑，业务逻辑定义）")]),_._v(" "),i("li",[_._v("在异步函数执行前可以对闭包访问的自由变量进行快照捕获：实现快照功能，在异步函数执行中可以通过ref读取最新的值")])])]),_._v(" "),i("li",[i("p",[_._v("内存泄漏（任何对象在您不再拥有或需要它之后仍然存在）常见操作")]),_._v(" "),i("ul",[i("li",[_._v("setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏")]),_._v(" "),i("li",[_._v("闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）")])])]),_._v(" "),i("li",[i("p",[_._v("通常情况下函数声明会覆盖变量声明，但如果变量有赋值操作，则变量声明会覆盖函数声明")])]),_._v(" "),i("li",[i("p",[_._v("匿名函数this指向为window")])]),_._v(" "),i("li",[i("p",[_._v("基本类型：undefined、boolean、string、number、symbol、null。引用数据类型：Object，比如Object、array、function")])]),_._v(" "),i("li",[i("p",[_._v("session 与 cookie 的区别")]),_._v(" "),i("ul",[i("li",[_._v("session 保存在服务器，客户端不知道其中的信息，cookie保存在客户端，服务器能够知道其中的信息")]),_._v(" "),i("li",[_._v("session 中保存的是对象，cookie 中保存的是字符串")]),_._v(" "),i("li",[_._v("session 不能区分路径，同一个用户在访问一个网站期间，所有的 session 在任何一个地方都可以访问到，而 cookie中如果设置了路径参数，那么同一个网站中不同路径下的 cookie 互相是访问不到的")])])]),_._v(" "),i("li",[i("p",[_._v("cookies，sessionStorage和localStorage的区别：是否会自动携带数据，路径限制，存储大小，有效期，作用域")])]),_._v(" "),i("li",[i("p",[_._v("new 操作符具体干了什么呢:")]),_._v(" "),i("ul",[i("li",[_._v("创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型")]),_._v(" "),i("li",[_._v("属性和方法被加入到 this 引用的对象中")]),_._v(" "),i("li",[_._v("新创建的对象由 this 所引用，并且最后隐式的返回 this")])])]),_._v(" "),i("li",[i("p",[_._v("前端性能优化操作：")]),_._v(" "),i("ul",[i("li",[_._v("减少 HTTP 请求数")]),_._v(" "),i("li",[_._v("压缩文件")]),_._v(" "),i("li",[_._v("使用内容分发网络（CDN）")]),_._v(" "),i("li",[_._v("设置缓存")]),_._v(" "),i("li",[_._v("将 JavaScript 脚本放在页面的底部")]),_._v(" "),i("li",[_._v("减少DOM操作")])])]),_._v(" "),i("li",[i("p",[_._v("prototype和__proto__区别：protptype是函数才有的属性，__proto__是每个对象都有的属性，大多数情况下__proto__可以理解为构造器的原型，即"),i("code",[_._v("__proto__ === constructor.prototype")]),_._v("，通过Object.create()创建的对象不适用此等式")])]),_._v(" "),i("li",[i("p",[_._v("如何判断一个变量是对象还是数组：")]),_._v(" "),i("ul",[i("li",[_._v("使用typeof加length属性，数组有length属性，object没有")]),_._v(" "),i("li",[_._v("使用instanceof，应该优先判断 array，最后判断 object")])])]),_._v(" "),i("li",[i("p",[_._v("设计模式：")]),_._v(" "),i("ul",[i("li",[_._v("单例模式")]),_._v(" "),i("li",[_._v("策略模式")]),_._v(" "),i("li",[_._v("代理模式")]),_._v(" "),i("li",[_._v("中介者模式")]),_._v(" "),i("li",[_._v("装饰者模式")])])]),_._v(" "),i("li",[i("p",[_._v("let和const定义的变量都会被提升，但是不会被初始化，不能被引用(先使用再定义会出现暂时死区)")])]),_._v(" "),i("li",[i("p",[_._v("Diff算法：")]),_._v(" "),i("ul",[i("li",[_._v("作用：计算出Virtual DOM中被修改的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面")]),_._v(" "),i("li",[_._v("策略:(三种策略的执行顺序也是顺序依次执行)\n"),i("ul",[i("li",[_._v("Tree Diff:是对树每一层进行遍历，找出不同")]),_._v(" "),i("li",[_._v("Component Diff:是数据层面的差异比较")]),_._v(" "),i("li",[_._v("Element Diff:真实DOM渲染，结构差异的比较")])])])])]),_._v(" "),i("li",[i("p",[_._v("在写组件时添加key的作用：使用key可以形成map映射，比遍历查找速度更快")])]),_._v(" "),i("li",[i("p",[_._v("TCP 三次握手和四次挥手")])])])])}),[],!1,null,null,null);v.default=e.exports}}]);