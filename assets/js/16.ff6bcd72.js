(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{515:function(e,v,_){"use strict";_.r(v);var t=_(4),c=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("ul",[_("li",[_("p",[e._v("派生类包含了一个构造函数，它 必须调用 "),_("code",[e._v("super()")]),e._v("，它会执行基类的构造函数。 而且，在构造函数里访问 "),_("code",[e._v("this")]),e._v(" 的属性之前，我们 一定要调用 "),_("code",[e._v("super()")])])]),e._v(" "),_("li",[_("p",[e._v("当成员被标记成 "),_("code",[e._v("private")]),e._v(" 时，它就不能在声明它的类的外部访问")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("protected")]),e._v(" 修饰符与 "),_("code",[e._v("private")]),e._v(" 修饰符的行为很相似，但有一点不同，"),_("code",[e._v("protected")]),e._v(" 成员在派生类中仍然可以访问")])]),e._v(" "),_("li",[_("p",[e._v("抽象类中的抽象方法不包含具体实现并且必须在派生类中实现")])]),e._v(" "),_("li",[_("p",[e._v("不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面")])]),e._v(" "),_("li",[_("p",[e._v("高级类型：交叉类型、联合类型")])]),e._v(" "),_("li",[_("p",[e._v("声明规范：")]),e._v(" "),_("ul",[_("li",[e._v("不要使用如下类型"),_("code",[e._v("Number")]),e._v("，"),_("code",[e._v("String")]),e._v("，"),_("code",[e._v("Boolean")]),e._v("或"),_("code",[e._v("Object")]),e._v("，应该使用类型"),_("code",[e._v("number")]),e._v("，"),_("code",[e._v("string")]),e._v("，"),_("code",[e._v("and boolean")])]),e._v(" "),_("li",[e._v("应该给返回值被忽略的回调函数设置"),_("code",[e._v("void")]),e._v("类型的返回值类型")]),e._v(" "),_("li",[e._v("不要在回调函数里使用可选参数除非你真的要这么做,应该写出回调函数的非可选参数,应该只使用最大参数个数写一个重载")]),e._v(" "),_("li",[e._v("不要把一般的重载放在精确的重载前面")]),e._v(" "),_("li",[e._v("不要为仅在末尾参数不同时写不同的重载，可以使用非可选参数")]),e._v(" "),_("li",[e._v("不要为仅在某个位置上的参数类型不同的情况下定义重载，可使用联合类型")])])]),e._v(" "),_("li",[_("h2",{attrs:{id:"_2020-05-23-补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2020-05-23-补充"}},[e._v("#")]),e._v(" 2020-05-23 补充")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("interface")]),e._v(" 和 "),_("code",[e._v("type")]),e._v(" 区别")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("相同点")]),e._v(" "),_("ul",[_("li",[e._v("都可以描述一个对象或者函数")]),e._v(" "),_("li",[e._v("都允许拓展（"),_("code",[e._v("extends")]),e._v("）")])])]),e._v(" "),_("li",[_("p",[e._v("不同点")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("type")]),e._v(" 可以声明基本类型别名，联合类型，元组等类型而 "),_("code",[e._v("interface")]),e._v(" 不行")]),e._v(" "),_("li",[_("code",[e._v("interface")]),e._v(" 能够声明合并而 "),_("code",[e._v("type")]),e._v(" 不行")])])])])]),e._v(" "),_("li",[_("p",[_("code",[e._v("TypeScript")]),e._v("具有三种"),_("code",[e._v("JSX")]),e._v("模式："),_("code",[e._v("preserve")]),e._v("，"),_("code",[e._v("react")]),e._v("和"),_("code",[e._v("react-native")])]),e._v(" "),_("ul",[_("li",[e._v("在"),_("code",[e._v("preserve")]),e._v("模式下生成代码中会保留"),_("code",[e._v("JSX")]),e._v("以供后续的转换操作使用（比如："),_("code",[e._v("Babel")]),e._v("）。 另外，输出文件会带有"),_("code",[e._v(".jsx")]),e._v("扩展名")]),e._v(" "),_("li",[_("code",[e._v("react")]),e._v("模式会生成"),_("code",[e._v("React.createElement")]),e._v("，在使用前不需要再进行转换操作了，输出文件的扩展名为"),_("code",[e._v(".js")])]),e._v(" "),_("li",[_("code",[e._v("react-native")]),e._v("相当于"),_("code",[e._v("preserve")]),e._v("，它也保留了所有的"),_("code",[e._v("JSX")]),e._v("，但是输出文件的扩展名是"),_("code",[e._v(".js")])])])]),e._v(" "),_("li",[_("p",[e._v("可以在"),_("code",[e._v("JSX.IntrinsicElements")]),e._v("上指定一个用来捕获所有字符串索引")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("declare namespace JSX {\n    interface IntrinsicElements {\n        [elemName: string]: any;\n    }\n}\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br")])])])])])])])}),[],!1,null,null,null);v.default=c.exports}}]);